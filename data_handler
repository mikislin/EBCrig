#Data visualization utility
import numpy as np
import pickle
import cv2
import pandas as pd
import io

    
#Note that we may to need to run this as a thread or multi-process so as not to interfere with the recording of the data
class data_handler():
    def __init__(self):
        self.rotary_ready = False
        self.cam_ready = False
        self.rot = []
        self.rot_time = []
        self.counter = 0
        
        #Wheel information for converting pulse/time to cm/s
        circ = 15.24*np.pi#Dimensions of Aeromat roller
        counts = 2000*4#Value for a 2000 PPR rotary encoder
        self.count2cm = circ/counts
        
    def parse_rotary(self,df):
        
        try:
            #Get timing of trials and rate arduino polls rotary encoder
            s2 = df
            s = io.StringIO(df)
            df = pd.read_csv(s,on_bad_lines='skip',names=['millis','event','value'])
            startIdx = np.where(df.event=='startTrial')[0]+1
            stopIdx = np.where(df.event=='stopTrial')[0]+1
            subDf = df[(df.index>startIdx[-1]) & (df.index<stopIdx[0]) & (df.event=='rotary')]
            subDf.loc[:,'millis'] = subDf['millis'].astype('float64')
            subDf.loc[:,'value'] = subDf['value'].astype('float64')
            # subDf.to_csv("sample"+str(self.counter)+".csv")
            time = subDf.millis.to_numpy() - subDf.millis.to_numpy()[0]#in ms
            pollrate = np.mean(np.diff(time))

            #Convert counts to cm/s
            wheelVel = subDf['value'].to_numpy()*self.count2cm/(pollrate/1000)
            wheelVel[wheelVel>1000] = np.nan
            
            self.rot = wheelVel
            self.rot_time = time
            self.counter += 1
        except Exception as e:
            #df.to_csv("badsample"+str(self.counter)+".csv")
            #text_file = open("badsample"+str(self.counter)+".txt", "w")
            #n = text_file.writelines(s2)
            #text_file.close()
            #self.counter += 1
            #print('Missed file<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<')
            print(e)

    def get_rotary(self):
        return self.rot,self.rot_time
        
    def process_cam(self,filename,roi):   
        #Open and unpickle the bytes file
        filehand = open(filename,'rb')
        stream = []
        while 1:
            try:
                stream.append(pickle.load(filehand))
            except EOFError:
                break
        filehand.close()
        #Removing the extra list packaging, getting nImages points
        stream = [x for l in stream for x in l]
        lists = [list(t) for t in zip(*stream)]
        self.eb_time = np.array(lists[0])*1000#convert to millis
        stream = lists[1]
        nIm = len(stream)

        #Reading through the binary file to parse image data
        idx = 0 #for buidling the np image array
        for img in stream:
            #grab frame start and end on hex stream
            a = img.find(b'\xff\xd8')
            b = img.find(b'\xff\xd9')
            if a != -1 and b != -1:
                jpg = img[a:b+2]
                #stream = stream[b+2:]
                data = cv2.imdecode(np.frombuffer(jpg, dtype=np.uint8), cv2.IMREAD_GRAYSCALE)
                
                if idx==0:
                    #For plot of line scan
                    sizeWH = data.shape
                    #Full output array
                    mov = np.empty([int(sizeWH[0]),int(sizeWH[1]),nIm],dtype=np.uint8)
                    mov[:,:,0] = data
                else:
                    mov[:,:,idx] = data
                idx += 1

            elif a==-1 or b==-1:
                pass

        # permute the data to put time element first
        imArray = np.transpose(mov,(2,0,1))
        self.eb = imArray.reshape([len(imArray), -1]) @ roi.reshape(np.product(roi.shape))
        
    def get_cam(self):
        return self.eb,self.eb_time
        
        
